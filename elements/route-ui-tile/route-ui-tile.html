<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
 * @module Route UI Elements
 */
/**
 * route-ui-tile
 *
 * Example:
 *
 *     <route-ui-tile>
 *       ...
 *     </route-ui-tile>
 *
 * @class route-ui-tile
 */
/**
 * Fired when the tile is tilted in some direction.
 *
 * @event route-ui-tile-tilt
 */
/**
 * Fired when the tile is pressed.
 *
 * @event route-ui-tile-press
 */
/**
 * Fired when the tile is released.
 *
 * @event route-ui-tile-release
 */
-->
<link rel="import" href="../components/polymer/polymer.html">

<polymer-element name="route-ui-tile" attributes="maxRotation autofireDelay autofireInterval autofire">
  <template>
    <link rel="stylesheet" href="route-ui-tile.css">
    <div id="tile">
      <content></content>
    </div>
  </template>
  <script>
    Polymer('route-ui-tile', {
      /**
       * Sets how much the tile should be able to rotate around the X/Y axes, in degrees.
       *
       * @attribute maxRotation
       * @type int
       * @default 15
       */
      maxRotation: 15,

      /**
       * Whether or not the tile should auto-fire zone events
       *
       * @attribute autofire
       * @type bool
       * @default false
       */
      autofire: false,

      /**
       * Amount of time to wait before automatically firing the first event, in milliseconds
       *
       * @attribute autofireDelay
       * @type int
       * @default 1000
       */
      autofireDelay: 1000,

      /**
       * Amount of time to wait between automatically firing events, in milliseconds
       *
       * @attribute autofireInterval
       * @type int
       * @default 100
       */
      autofireInterval: 100,

      ready: function() {
        this.pointerStartListener = this.pointerStart.bind(this);
        this.pointerMoveListener = this.pointerMove.bind(this);
        this.pointerEndListener = this.pointerEnd.bind(this);

        var hasTouch = ("ontouchstart" in document.documentElement);
        this.startEvent = hasTouch ? "touchstart" : "mousedown";
        this.moveEvent = hasTouch ? "touchmove" : "mousemove";
        this.endEvent = hasTouch ? "touchend" : "mouseup";

        this.addEventListener(this.startEvent, this.pointerStartListener);
      },
      leftView: function() {
        this.removeEventListener(this.startEvent, this.pointerStartListener);
      },
      animate: function(percentX, percentY, raised) {
        var bound = function(value, min, max) {
          if(value < min) return min;
          if(value > max) return max;
          return value;
        };

        var rotationX = bound(percentX, -1, 1) * 15,
            rotationY = bound(percentY, -1, 1) * 15;

        var s = this.$.tile.style;
        var transform = raised ? "translate3d(0,0,20px)" : "";
        var rotate = "rotateX("+rotationY+"deg) rotateY("+rotationX+"deg)";

        s.webkitTransform = s.mozTransform = s.msTransform = s.transform =
            transform + " " + rotate;
      },
      updateDimensions: function() {
        this.dimensions = {};

        var x = 0, y = 0;
        for(var el = this; el != null; x += el.offsetLeft, y += el.offsetTop, el = el.offsetParent);
        this.dimensions.left = x;
        this.dimensions.top = y;
        this.dimensions.width = this.offsetWidth;
        this.dimensions.height = this.offsetHeight;
        this.dimensions.centerX = this.dimensions.left + (this.dimensions.width / 2);
        this.dimensions.centerY = this.dimensions.top + (this.dimensions.height / 2);
      },
      updateStartingPosition: function(clientX, clientY) {
        this.start = {
          x: clientX,
          y: clientY,
        };
      },
      updateLatestPosition: function(clientX, clientY) {
        var distX = clientX - this.start.x,
            distY = clientY - this.start.y;

        this.latest = {
          x: clientX,
          y: clientY,
          percent: {
            x: (clientX - this.dimensions.centerX) * 2 / this.dimensions.width,
            y: -(clientY - this.dimensions.centerY) * 2 / this.dimensions.height,
          },
          distance: Math.sqrt(distX*distX + distY*distY),
        };
      },
      updateZone: function() {
        var x = this.latest.percent.x,
            y = this.latest.percent.y;

        if(Math.sqrt(x*x + y*y) < .5) {
          this.zone = "center";
        } else if(this.latest.percent.x > this.latest.percent.y) {
          this.zone = (this.latest.percent.x > -this.latest.percent.y) ? "right" : "bottom";
        } else {
          this.zone = (this.latest.percent.x > -this.latest.percent.y) ? "top" : "left";
        }
      },
      pointerStart: function(e) {
        e.preventDefault();

        document.addEventListener(this.moveEvent, this.pointerMoveListener);
        document.addEventListener(this.endEvent, this.pointerEndListener);

        var clientX = e.clientX || e.touches[0].clientX,
            clientY = e.clientY || e.touches[0].clientY;

        this.fired = false;
        this.updateDimensions();
        this.updateStartingPosition(clientX, clientY);
        this.updateLatestPosition(clientX, clientY);
        this.updateZone();
        this.animate(0, 0, true);

        this.$.tile.classList.add('dragging');

        this.positionUpdated();
      },
      pointerMove: function(e) {
        e.preventDefault();

        var clientX = e.clientX || e.touches[0].clientX,
            clientY = e.clientY || e.touches[0].clientY;

        this.updateLatestPosition(clientX, clientY);
        this.updateZone();
        this.animate(this.latest.percent.x, this.latest.percent.y, true);

        this.positionUpdated();
      },
      pointerEnd: function(e) {
        e.preventDefault();

        document.removeEventListener(this.moveEvent, this.pointerMoveListener);
        document.removeEventListener(this.endEvent, this.pointerEndListener);

        this.$.tile.classList.remove('dragging');
        this.animate(0, 0);

        this.clearTimers();
        this.lastZone = null;

        if(!this.fired) {
          this.fire("route-ui-tile-" + this.zone, this.latest);
        }
      },
      clearTimers: function() {
        if(this.fireTimer) clearTimeout(this.fireTimer);
        if(this.keepFiringTimer) clearTimeout(this.keepFiringTimer);
      },
      positionUpdated: function() {
        if(this.autofire && (!this.lastZone || this.lastZone != this.zone)) {
          this.lastZone = this.zone;
          this.clearTimers();
          this.fireTimer = setTimeout(this.keepFiring.bind(this), this.autofireDelay);
        }
      },
      keepFiring: function() {
        this.fired = true;
        this.fire("route-ui-tile-" + this.zone, this.latest);
        console.log(this.autofireInterval);
        this.keepFiringTimer = setTimeout(this.keepFiring.bind(this), this.autofireInterval);
      },
    });
  </script>
</polymer-element>