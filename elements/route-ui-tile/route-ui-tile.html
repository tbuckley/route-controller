<!--
Copyright 2013 The Polymer Authors. All rights reserved.
Use of this source code is governed by a BSD-style
license that can be found in the LICENSE file.
-->

<!--
/**
 * @module Route UI Elements
 */
/**
 * route-ui-tile
 *
 * Example:
 *
 *     <polymer-ui-tile>
 *       ...
 *     </polymer-ui-tile>
 *
 * @class route-ui-tile
 */
/**
 * Fired when the card is swiped away.
 *
 * @event polymer-card-swipe-away
 */
-->
<link rel="import" href="../components/polymer/polymer.html">

<polymer-element name="route-ui-tile" attributes="swipeable noCurve">
  <template>
    <link rel="stylesheet" href="route-ui-tile.css">
    <div id="message" hidden?="{{!messageVisible}}">{{message}}</div>
    <div id="tile">
      <content></content>
    </div>
  </template>
  <script>
    Polymer('route-ui-tile', {
      /**
       * Sets how much the tile should be able to rotate around the X/Y axes, in degrees.
       *
       * @attribute maxRotation
       * @type int
       * @default 15
       */
      maxRotation: 15,

      messageVisible: true,
      message: "100",

      ctr: 0,

      ready: function() {
        // this.transitionEndListener = this.transitionEnd.bind(this);
        this.pointerStartListener = this.pointerStart.bind(this);
        this.pointerMoveListener = this.pointerMove.bind(this);
        this.pointerEndListener = this.pointerEnd.bind(this);

        var hasTouch = ("ontouchstart" in document.documentElement);
        this.startEvent = hasTouch ? "touchstart" : "mousedown";
        this.moveEvent = hasTouch ? "touchmove" : "mousemove";
        this.endEvent = hasTouch ? "touchend" : "mouseup";

        this.addListeners();
      },
      leftView: function() {
        this.removeListeners();
      },
      addListeners: function() {
        // this.addEventListener('webkitTransitionEnd', this.transitionEndListener);
        // this.addEventListener('transitionend', this.transitionEndListener);
        this.addEventListener(this.startEvent, this.pointerStartListener);
      },
      removeListeners: function() {
        // this.removeEventListener('webkitTransitionEnd',this.transitionEndListener);
        // this.removeEventListener('transitionend', this.transitionEndListener);
        this.removeEventListener(this.startEvent, this.pointerStartListener);
      },
      animate: function(diffX, diffY, raised) {
        var bound = function(value, min, max) {
          if(value < min) return min;
          if(value > max) return max;
          return value;
        };

        var x = (diffX * 2 / this.w),
            y = (diffY * 2 / this.h);
        var rotationX = bound(x, -1, 1) * 15,
            rotationY = bound(-y, -1, 1) * 15;

        var s = this.$.tile.style;
        var transform = raised ? "translate3d(0,0,20px)" : "";
        var rotate = "rotateX("+rotationY+"deg) rotateY("+rotationX+"deg)";

        s.webkitTransform = s.mozTransform = s.msTransform = s.transform =
            transform + " " + rotate;
      },
      pointerStart: function(e) {
        e.preventDefault();

        document.addEventListener(this.moveEvent, this.pointerMoveListener);
        document.addEventListener(this.endEvent, this.pointerEndListener);

        this.x = this.offsetLeft;
        this.y = this.offsetTop;
        for(var el = this.offsetParent;
            el != null;
            this.x += el.offsetLeft, this.y += el.offsetTop, el = el.offsetParent);
        this.w = this.offsetWidth;
        this.h = this.offsetHeight;
        this.cx = this.x + (this.w / 2);
        this.cy = this.y + (this.h / 2);

        this.startX = this.endX = e.clientX || e.touches[0].clientX;
        this.startY = this.endY = e.clientY || e.touches[0].clientY;

        this.animate(0, 0, true);
        this.async(function() {
          this.$.tile.classList.add('dragging');
        }.bind(this));

        this.positionUpdated();
      },
      pointerMove: function(e) {
        e.preventDefault();

        this.endX = e.clientX || e.touches[0].clientX,
        this.endY = e.clientY || e.touches[0].clientY;
        this.animate(this.endX - this.cx, this.endY - this.cy, true);

        this.positionUpdated();
      },
      pointerEnd: function(e) {
        e.preventDefault();

        document.removeEventListener(this.moveEvent, this.pointerMoveListener);
        document.removeEventListener(this.endEvent, this.pointerEndListener);

        this.$.tile.classList.remove('dragging');
        this.animate(0, 0);
        console.log("TRACKEND", this.dx, this.dy);

        this.clearTimers();
        this.lastZone = null;
      },
      clearTimers: function() {
        if(this.fireTimer) {
          clearTimeout(this.fireTimer);
        }
        if(this.keepFiringTimer) {
          clearTimeout(this.keepFiringTimer);
        }
      },
      positionUpdated: function() {
        var zone = "foo";
        if(!this.lastZone || this.lastZone != zone) {
          this.lastZone = zone;
          this.clearTimers();
          this.fireTimer = setTimeout(this.keepFiring.bind(this), 1000)
        }
      },
      keepFiring: function() {
        this.fireEvent();
        this.keepFiringTimer = setTimeout(this.keepFiring.bind(this), 100);
      },
      fireEvent: function() {
        console.log("FIRE");
        var percentX = (this.endX - this.cx) * 2 / this.w,
            percentY = (this.endY - this.cy) * 2 / this.h,
            distX = this.endX - this.startX,
            distY = this.endY - this.startY,
            movement = Math.sqrt(distX*distX + distY*distY);

        var details = {
          distance: movement,
          percentX: percentX,
          percentY: percentY,
        };

        if(percentY > 0.3) {
          this.ctr += 1;
          this.showMessage(this.ctr);
          return "top";
        } else if(percentY < 0.3) {
          this.ctr -= 1;
          this.showMessage(this.ctr);
          return "bottom";
        }
      },
      showMessage: function(msg) {
        this.message = msg;
        // this.messageVisible = true;

        if(this.messageTimer) {
          clearTimeout(this.messageTimer);
        }
        this.messageTimer = setTimeout(function() {
          this.$.message.style.opacity = 0;
        }.bind(this), 1000);

        this.async(function() {
          this.$.message.style.opacity = 1;
        }.bind(this));
      }
    });
  </script>
</polymer-element>