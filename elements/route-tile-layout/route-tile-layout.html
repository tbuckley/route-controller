<link rel="import" href="../polymer/polymer.html">

<polymer-element name="route-tile-layout" attributes="nodes layout auto">
  <template>
  </template>
  <script>
    (function() {
      // Heavily based on polymer-grid-layout
      Polymer("route-tile-layout", {
        nodes: null,
        layout: null,
        auto: false,
        created: function() {
          this.layout = [];
        },
        nodesChanged: function() {
          console.log("nodes changed");
          this.invalidate();
        },
        layoutChanged: function() {
          console.log("layout changed");
          this.invalidate();
        },
        autoNodes: function() {
          this.nodes = this.parentNode.children.array().filter(function(node) {
            switch(node.localName) {
              case "route-tile-layout":
              case "style":
                return false
            }
            return true;
          });
        },
        // invalidate will relayout the nodes. It debounces calls so that
        // relayout isn't called too frequently
        invalidate: function() {
          console.log("INVALIDATE CALLED");
          if(this.layout && this.layout.length) {
            // this.job debounces layout, only letting it occur every N ms
            // debouncing: http://davidwalsh.name/function-debounce
            this.layoutJob = this.job(this.layoutJob, this.relayout);
          }
        },
        // Note: don't call directly, use invalidate() instead
        relayout: function() {
          if(!this.nodes || this.auto) {
            this.autoNodes();
          }
          layout(this.layout, this.nodes, this.parentNode);
          this.asyncFire("route-tile-layout");
        }
      });

      var colCount, colOwners, rowCount, rowOwners;

      function matrixillate(matrix) {
        // mesaure the matrix, must be rectangular
        rowCount = matrix.length;
        colCount = rowCount && matrix[0].length || 0;
        // transpose matrix
        var transpose = [];
        for (var i=0; i<colCount; i++) {
          var c = [];
          for (var j=0; j<rowCount; j++) {
            c.push(matrix[j][i]);
          }
          transpose.push(c);
        }
        // assign sizing control
        colOwners = findOwners(matrix);
        rowOwners = findOwners(transpose);
      }

      function findOwners(matrix) {
        var majCount = matrix.length;
        var minCount = majCount && matrix[0].length || 0;
        var owners = [];
        // for each column (e.g.)
        for (var i=0; i<minCount; i++) {
          // array of contained areas
          var contained = {};
          // look at each row to find a containing area
          for (var j=0; j<majCount; j++) {
            // get the row vector
            var vector = matrix[j]
            // node index at [i,j]
            var nodei = vector[i];
            // if a node is there
            if (nodei) {
              // determine if it bounds this column
              var owns = false;
              if (i === 0) {
                owns = (i === minCount-1) || (nodei !== vector[i+1]);
              } else if (i === minCount - 1) {
                owns = (i === 0) || (nodei !== vector[i-1]);
              } else {
                owns = nodei !== vector[i-1] && nodei !== vector[i+1];
              }
              if (owns) {
                contained[nodei] = 1;
              }
            }
            // store the owners for this column
            owners[i] = contained;
          }
        }
        return owners;
      }

      // TODO: this code tries to preserve actual position,
      // so 'unposition' is really 'naturalize' or something
      function unposition(box) {
        var style = box.style;
        //style.right = style.bottom = style.width = style.height = '';
        style.position = 'absolute';
        style.display = 'inline-block';
        style.boxSizing = style.mozBoxSizing = 'border-box';
      }

      function _position(style, maj, min, ext, a, b) {
        style[maj] = a + "px";
        // style[min] = b + "px";
        style[ext] = (b - a) + "px";
      }

      function position(elt, left, right, top, bottom) {
        console.log("POSITION", left, right, top, bottom);
        elt.style["display"] = "block";
        _position(elt.style, 'top', 'bottom', 'height', top * unit, bottom * unit);
        _position(elt.style, 'left', 'right', 'width', left * unit, right * unit);
      }

      // Custom
      function calculateUnit(node, cols, rows) {
        console.log("Node dimensions: ", node.offsetWidth, node.offsetHeight);
        var w = Math.floor(node.offsetWidth / cols),
            h = Math.floor(node.offsetHeight / rows);
        return Math.min(h, w);
      }

      var unit;
      var m = 0;

      function layout(matrix, anodes, parent) {
        console.log("LAYOUT CALLED");
        nodes = anodes;
        matrixillate(matrix);

        nodes.forEach(unposition);

        unit = calculateUnit(parent, colCount, rowCount);
        console.log("Unit: ", unit)

        nodes.forEach(function(node, i) {
          // node indices are 1-based
          var n = i + 1;
          // boundary rails
          var l, r, t = 1e10, b = -1e10;
          matrix.forEach(function(vector, i) {
            var f = vector.indexOf(n);
            if (f > -1) {
              l = f;
              r = vector.lastIndexOf(n) + 1;
              t = Math.min(t, i);
              b = Math.max(b, i) + 1;
            }
          });
          if (l == undefined) {
            node.style.position = 'absolute';
            node.style.pointerEvents = 'none';
          } else {
            node.style.pointerEvents = '';
            position(node, l, r, t, b);
          }
        });
      }

    })();
  </script>
</polymer-element>